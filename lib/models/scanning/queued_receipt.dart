import 'package:hive/hive.dart';
import 'queued_item.dart';

// This will be generated by build_runner
part 'queued_receipt.g.dart';

/// Hive model for storing receipts in the offline queue
///
/// When a user scans a receipt while offline, it's converted to a QueuedReceipt
/// and stored locally. When connectivity returns, these are processed and synced
/// to Supabase.
@HiveType(typeId: 0)
class QueuedReceipt extends HiveObject {
  /// Unique identifier (UUID)
  @HiveField(0)
  String id;

  /// When this receipt was queued
  @HiveField(1)
  DateTime queuedAt;

  /// List of items to be created as expenses
  @HiveField(2)
  List<QueuedItem> items;

  /// Number of retry attempts
  @HiveField(3)
  int retryCount;

  /// When the last retry attempt was made
  @HiveField(4)
  DateTime? lastRetryAt;

  /// Error message from last failure (if any)
  @HiveField(5)
  String? errorMessage;

  /// Current status of this queued receipt
  @HiveField(6)
  String status; // 'pending', 'retrying', 'syncing', 'failed', 'success'

  QueuedReceipt({
    required this.id,
    required this.queuedAt,
    required this.items,
    this.retryCount = 0,
    this.lastRetryAt,
    this.errorMessage,
    this.status = 'pending',
  });

  /// Check if this receipt can be retried
  bool get canRetry => retryCount < 5 && status != 'success';

  /// Check if this receipt is stale (queued > 24 hours ago)
  bool get isStale {
    final now = DateTime.now();
    return now.difference(queuedAt).inHours > 24;
  }

  /// Total amount of all items
  double get totalAmount {
    return items.fold(0.0, (sum, item) => sum + item.amount);
  }

  /// Number of items
  int get itemCount => items.length;

  /// Convert to JSON for debugging
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'queuedAt': queuedAt.toIso8601String(),
      'items': items.map((item) => item.toJson()).toList(),
      'retryCount': retryCount,
      'lastRetryAt': lastRetryAt?.toIso8601String(),
      'errorMessage': errorMessage,
      'status': status,
    };
  }

  /// Create from JSON
  factory QueuedReceipt.fromJson(Map<String, dynamic> json) {
    return QueuedReceipt(
      id: json['id'] as String,
      queuedAt: DateTime.parse(json['queuedAt'] as String),
      items: (json['items'] as List)
          .map((item) => QueuedItem.fromJson(item as Map<String, dynamic>))
          .toList(),
      retryCount: json['retryCount'] as int? ?? 0,
      lastRetryAt: json['lastRetryAt'] != null
          ? DateTime.parse(json['lastRetryAt'] as String)
          : null,
      errorMessage: json['errorMessage'] as String?,
      status: json['status'] as String? ?? 'pending',
    );
  }

  @override
  String toString() {
    return 'QueuedReceipt(id: $id, queuedAt: $queuedAt, '
        'itemCount: $itemCount, totalAmount: $totalAmount, '
        'retryCount: $retryCount, status: $status)';
  }
}
